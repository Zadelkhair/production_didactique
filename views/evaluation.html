<!doctype html>
<html lang="en">

<head>
    <title>Title</title>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

    <style>
        body {
            overflow: hidden;
        }

        hr {
            margin: 5px 0;
            border: solid 1px rgba(0, 0, 0, 0.041);
            width: 100%;
        }

        #app {
            height: 100%;
            width: 100%;
        }

        #controls {
            width: 200px;
            position: absolute;
            right: 10px;
            top: 10px;
            display: flex;
            background: white;
            border: solid rgb(238, 238, 238);
            border-width: 1px;
            padding: 10px;
            flex-direction: column;
            align-items: center;
            height: calc(100% - 10px*2);
            box-shadow: 0 0 20px 0 #0000001c;
            opacity: .2;
            transition: 1s ease;
        }

        #controls:hover {
            opacity: 1;
        }

        #controls * {
            font-size: 12px !important;
        }

        #parts {
            display: flex;
            height: 200px;
            background: rgb(240, 240, 240);
            width: 100%;
            flex-direction: column;
            overflow-y: scroll;
            padding: 4px 2px 4px 4px;
        }

        #parts::-webkit-scrollbar {
            width: 3px;
        }

        #parts::-webkit-scrollbar-track {}

        #parts::-webkit-scrollbar-thumb {
            background-color: darkgrey;
        }

        .part-item {
            padding: 2px 5px;
            display: flex;
            align-items: center;
            background: rgb(253, 253, 253);
            margin-bottom: 3px;
            border: 1px solid gainsboro;
        }

        .part-item label {
            padding: 0;
            margin: 5px;
            margin-right: auto;
        }

        .part-item:hover {
            background: rgb(248, 248, 248);
            cursor: pointer;
        }

        .part-item-selected {
            background-color: #0d6efd;
            border-color: #0d6efd;
            color: white;
        }

        .part-item-selected * {
            color: white;
        }

        .part-item-selected:hover {
            background-color: #0b5ed7;
            border-color: #0a58ca;
        }

        .my-btn {
            border-style: none;
            background: transparent;
            text-align: center;
            justify-content: center;
            display: flex;
            margin: 0;
            padding: 3px;
        }

        .my-btn:hover {
            font-weight: bold;
        }

        #proprieties {
            display: flex;
            height: 200px;
            width: 100%;
            flex-direction: column;
            overflow-y: scroll;
            padding: 4px 2px 4px 4px;
            background: rgb(240, 240, 240);
        }

        #proprieties::-webkit-scrollbar {
            width: 3px;
        }

        #proprieties::-webkit-scrollbar-track {}

        #proprieties::-webkit-scrollbar-thumb {
            background-color: darkgrey;
        }

        .prop {
            font-size: 12px;
            padding: 2px 5px;
            display: flex;
            flex-direction: column;
            margin-bottom: 3px;
        }

        .prop input {
            margin: 0;
        }

        #proprieties .label-group {
            font-size: 12px;
            font-weight: bold;
        }

        .my-btn-delete {
            padding: 0;
            margin: 0;
            background: transparent;
            border: none;
            color: red;
        }

        .my-btn-delete:hover {
            font-weight: bold;
        }

        #participants {
            display: flex;
            margin-top: 10px;
            width: 100%;
            flex-direction: column;
        }

        .participant {
            text-align: left;
            font-size: 14px;
            background: rgb(241, 241, 241);
            border: solid 1px rgb(216, 216, 216);
            padding: 5px 10px;
            display: flex;
            align-items: center;
            margin-bottom: 3px;
        }

        .participant .online {
            height: 10px;
            width: 10px;
            border-radius: 100%;
            background: greenyellow;
            margin-right: 10px;
        }

        .participant .particip {
            /* if text is large add 3 dots (...) */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>

    <style id="part_style">
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.4/gsap.min.js"></script>
    <script src="https://unpkg.com/vue@3"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.27.2/axios.min.js"
        integrity="sha512-odNmoc1XJy5x1TMVMdC7EMs3IVdItLPlCeL5vSUPN2llYKMJ2eByTTAIiiuqLg+GdNr9hF6z81p27DArRFKT7A=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script src="/socket.io/socket.io.js"></script>

</head>

<body>

    <div id="app">

        <span v-html="html"></span>
        <div id="controls">
            <div class="d-flex mb-2">
                <button class="btn btn-sm btn-success mr-2" @click="startPart()" type="button">start</button>
                <button class="btn btn-sm btn-danger mr-2" @click="stop(true)" type="button">stop</button>
            </div>
            <hr>
            <!-- <label id="ani-progress" class="control">{{progress}} %</label> -->
            <div class="d-flex align-items-center">
                <!-- <input class="me-2" type="number" :value="parseInt(progress*100)" @change="progressChanged">% -->
                {{parseInt(progress*100)}}%
            </div>
            <div class="d-flex align-items-center my-2">
                <!-- <button class="btn btn-sm btn-primary me-2" id="btn-play" disabled @click="resume()"
                    type="button">play</button> -->
                <!-- <button class="btn btn-sm btn-primary" id="btn-pause" disabled @click="pause()"
                    type="button">pause</button> -->
            </div>
            <hr>
            <hr>
            <label for="">parts :</label>
            <div id="parts">
                <div v-for="(part,key) in evaluation.parts" @click="selectPart(part)" :key="key" class="part-item"
                    :class="selected_part==part?'part-item-selected':''">
                    <label for="">{{ part.name }}</label>
                    <button class="my-btn ms-auto" @click.stop="upPart(key)">up</button>
                    <button class="my-btn m-0" @click.stop="downPart(key)">down</button>
                    <button class="my-btn-delete m-0" @click.stop="deletePart(key)">x</button>
                </div>
            </div>
            <hr>
            <label for="">participants :</label>
            <div id="participants">
                <div v-for="(participant,key) in participants" :key="key" class="participant">
                    <div class="online"></div>
                    <div class="particip me-1">{{participant.username}}</div>
                    <div class="ml-auto">{{parseInt((participant?.progress??0)*100)}}%</div>
                    <button class="btn btn-sm btn-primary py-0 ml-1"
                        @click="restartParticipantPart(participant)">R</button>
                    <button class="btn btn-sm btn-danger py-0 ml-1" @click="stopParticipantPart(participant)">S</button>
                </div>
            </div>
            <label for="">answers :</label>
            <!-- show participantsAnswersModal modal -->
            <button class="btn w-100 btn-primary" @click="showParticipantsAnswersModal">show answers</button>
        </div>

        <!-- participants answers modal -->
        <div class="modal  fade" id="participantsAnswersModal" tabindex="-1" role="dialog"
            aria-labelledby="participantsAnswersModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg" role="document">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="participantsAnswersModalLabel">participants answers</h5>
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">

                        <!-- show participants answers -->
                        <div class="participantes" v-for="(participant,key) in participants">

                            <span class="particip">{{participant.username}}</span>
                            <div class="participant-answers">
                                <div v-for="(answer,key) in participant.answers" :key="key" class="answer ml-4">
                                    <strong> {{ key+1 }} : </strong><span class="answer-text">{{answer}}</span>
                                </div>
                            </div>
                            <hr>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JavaScript Libraries -->
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
        integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"
        integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p"
        crossorigin="anonymous"></script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js"
        integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF"
        crossorigin="anonymous"></script>

    <script id="part_script"></script>
    <script id="part_admin_script"></script>

    <script>
        let socket = io();

        //get the style element where we will put the part css
        let styleElem = document.getElementById('part_style');
        //get the script element where we will put the part script
        let scriptElem = document.getElementById('part_script');
        // admin script element where we will put the admin script
        let adminScriptElem = document.getElementById('part_admin_script');

        let tl;

        //the timeline
        tl = gsap.timeline();

        let app = Vue.createApp({
            data() {
                return {
                    evaluation: {},
                    selected_part: {},
                    progress: 0,
                    css: '',
                    html: '',
                    script: '',
                    admin_script: '',
                    gsap: [],
                    playingVideos: [],
                    endTimeline: false,
                    participants: [],
                    room: ''
                }
            },
            watch: {
                css(newV, oldV) {
                    styleElem.innerHTML = newV;
                },
                script(newV, oldV) {
                    scriptElem.innerHTML = newV;
                },
                admin_script(newV, oldV) {
                    adminScriptElem.innerHTML = newV;
                }
            },
            mounted() {

                //if the url is not containing the room go to the main page
                let url = window.location.href;
                if (!url.includes('room')) {
                    window.location.href = '/';
                }

                //get evaluation part id
                url = new URL(url);
                let room = url.searchParams.get('room');

                this.room = room;

                //loading the evaluation and its parts
                axios.get('/api/evaluation?room=' + room)
                    .then((response) => {

                        this.evaluation = response.data;

                        setInterval(() => {
                            if (!tl) return;
                            if (this.progress != tl.progress())
                                this.progress = tl.progress();
                        }, 100);

                        this.connectToRoom(room);

                    })
                    .catch(function (error) {
                        // handle error
                        // window.location.href = '/';
                        console.log(error);
                    });

            },
            methods: {
                loadVideoResources(resources, callback) {

                    //if resources is null go out from function
                    if (resources.length == 0)
                        callback();

                    //the loaded data to chek if all resources has been loaded
                    let loaded = 0;
                    let canPlay = 0;
                    let error = 0;

                    //loop throuph all resources and load theme
                    resources.forEach((rs) => {
                        //get resource element to load the video on it
                        let vid = document.querySelector(rs.id);

                        //if the element not exist create it
                        if (!vid) {
                            vid = document.createElement('video');
                            vid.id = rs.id.substring(1);
                            // add element to #app element
                            document.getElementById('app').appendChild(vid);
                            //add d-note class
                            vid.classList.add('d-none');
                        }

                        if (vid) {
                            var new_element = vid.cloneNode(true);
                            vid.parentNode.replaceChild(new_element, vid);
                        }
                        vid = document.querySelector(rs.id);

                        console.log(vid);

                        if (!rs.url) {
                            rs.url = '/static/err.mp3';
                        }

                        //stop if vid is null
                        if (!vid) {
                            return;
                        }

                        vid.src = rs.url;
                        vid.load();

                        //if the video is not valid
                        vid.addEventListener("error", () => {
                            //we will encriment the loaded, bcz the video is not valid
                            error++;
                            console.log('error : ', error, vid.src);
                            if (canPlay + error == resources.length) {
                                //we will call the callback function if all resources loaded
                                callback();
                            }
                        }, true);

                        //to check if the element has a valid video
                        vid.addEventListener("loadeddata", () => {

                            //load the video

                            //it will be incrimented on every load
                            // and we will check if all video has been loaded!
                            canPlay++;
                            console.log('can play : ', canPlay, vid.src);
                            if (canPlay + error == resources.length) {
                                //we will call the callback function if all resources loaded
                                callback();
                            }

                            // //event whene the first frame will loaded
                            // vid.addEventListener('loadeddata', () => {


                            // }, false);

                            //we will remove all event listener after ending the media
                            vid.addEventListener('ended', () => {
                                if (vid) {
                                    var new_element = vid.cloneNode(true);
                                    vid.parentNode.replaceChild(new_element, vid);
                                }
                            })

                        });

                        // return;

                    });
                    // callback();
                },
                async load(p = 0) {

                    // it will pause the animation if it still playing
                    this.pause(p);

                    //initialize the timeline for new use
                    tl = gsap.timeline();

                    //this variable will hold all the resources that chould be loaded
                    let resources = [];

                    //loop throuph the gsap list and check if there any video animation
                    this.gsap.forEach((v) => {
                        if (v.type == 'videoplayer') {
                            resources.push({
                                id: v.id,
                                url: v.url
                            });
                        }
                    });

                    //load all the videos and wait untill they loaded
                    this.loadVideoResources(resources, () => {

                        //tl = gsap.timeline();

                        //we will use this variable to check if the time line has been ended or not
                        this.endTimeline = false;

                        //playing video list
                        this.playingVideos = [];

                        //start the animations
                        this.gsap.forEach((v) => {

                            //do some work based on the type of gsap item's
                            if (v.type == 'object') {
                                tl.fromTo(v.id, { ...v.from }, { ...v.to }, v.at);
                            }
                            else if (v.type == 'video') {
                                tl.fromTo(v.id, { ...v.from }, { ...v.to }, v.at);
                            }
                            else if (v.type == 'videoplayer') {
                                //we will play the videos inside a call function
                                // the GSAP don't support videos
                                //to add this feature we will stop the animation untill the end of the video
                                // and we will play the video again 
                                tl.call(() => {

                                    //if the timeline is paused then we should'nt play the video
                                    if (tl.paused()) return;

                                    //get the video id without hashtag '#' from the gsap item
                                    let videoId = v.id.replace('#', '');

                                    //get the element by the video id
                                    var vid1 = document.getElementById(videoId);

                                    //play the video
                                    vid1.play();

                                    //add event waiting the video untill it start playing
                                    vid1.addEventListener("play", () => {

                                        //add the video id the the playing video list
                                        //we need this variable to check if there any video still playing
                                        this.playingVideos.push(videoId);

                                        // we will add some labels to the timeline
                                        // we need inside the pause and play functions
                                        // to decide if we should play the video or the animation
                                        let label = `vid@${videoId}`;

                                        //we add this to add the possibility of playing the video along with animations
                                        //we will add the some string to use it inside pause and play function
                                        //bcz if the video is playing along with the animation we should pause/play them bouth
                                        if (v.playwith)
                                            label += '@playwith';

                                        //add lable to the timeline
                                        tl.addLabel(label);

                                        //if the video is not playing with animation we should pause the animation untill the video ended
                                        if (!v.playwith)
                                            tl.pause();

                                        console.log(label);

                                        //on the video ended we should play the animation
                                        vid1.onended = () => {

                                            //algorithm to delete the video from the playing video list
                                            var vindex = this.playingVideos.indexOf(videoId);
                                            if (vindex !== -1) {
                                                this.playingVideos.splice(vindex, 1);
                                            }

                                            //remove the video label from timeline
                                            tl.removeLabel(label);

                                            //if the video is playing with then the animation is alredy playing
                                            if (!v.playwith)
                                                tl.resume();

                                            //if the playing list is empty and the timeline is ended, we will stop the timeline
                                            if (this.playingVideos.length == 0 && this.endTimeline) {
                                                this.stop();
                                            }

                                        }

                                    });


                                }, null, v.at);
                            }
                            else if (v.type == 'label') {
                                //add label to the timeline
                                tl.addLabel(v.name);
                            }
                            else if (v.type == 'goto') {
                                //jump to a specific label
                                tl.call(() => tl.seek(v.label), null, v.at)
                            }
                            else if (v.type == 'customefunction') {
                                //execute the custom function in timeline call
                                tl.call(() => {

                                    if (v.wait) {
                                        //check if the tl is already paused 
                                        let paused = tl.paused();

                                        this.pause();
                                        part[v.func](() => {
                                            if (paused) return;
                                            // this.play();
                                        });

                                    }
                                    else {
                                        part[v.func]();
                                    }

                                }, null, v.at)
                            }
                        });

                        //this call function will be called whene the animation is ended
                        tl.call(() => {

                            //we will set the this.endTimeline to true bcz the animmation is ended
                            //we will use this variable to stop the animation if the video is still playing
                            this.endTimeline = true;

                            //if the playing list already containing some videos we should not stoping the animations
                            if (this.playingVideos.length != 0)
                                return;

                            //stop the animation
                            this.stop();
                        });

                        //pause untill we press the play button
                        // tl.pause();

                        //we can jump on a specific progress in timeline with the p variable
                        tl.progress(p);

                        // document.getElementById('btn-play').disabled = false;

                    });

                },
                //if the user change the progress bar we will jump to the chosen progress on the timeline and pause it
                progressChanged(e) {
                    let val = e.target.value;
                    tl.progress(val / 100);
                    this.pause();
                },
                //stop the timeline & reload it
                stop(stopPartInAllConnectedSockets = false) {
                    tl.pause();
                    this.selectPart();
                    tl = gsap.timeline();
                    // this.load();

                    if (stopPartInAllConnectedSockets)
                        socket.emit('stoppart.' + this.room);
                },
                //play function will play the animation
                play(p = null) {

                    //we will check first if the timeline is paused on a video
                    if (tl.nextLabel()?.indexOf('vid') == 0) {

                        //split the label and get the id of the video & the type of playing (playing with or not)
                        let splitedLabel = tl.nextLabel().split('@');

                        //check if the label is containing more than 2 parameters.
                        //if not you should go out from the function
                        if (splitedLabel.length < 2)
                            return;

                        //initializing the playwith with false
                        let playwith = false;

                        //if the label containing 3 parameters and the 3'd paramater is playingwith then change the playwith variable to true
                        if (splitedLabel.length > 2)
                            if (splitedLabel[2] == 'playwith')
                                playwith = true;

                        //get the id of the played video 
                        var vidid = splitedLabel[1];

                        //get the element of the played video using the id to play it
                        var currVid = document.getElementById(vidid);

                        //play the video
                        currVid.play();

                        // //enable pause button and play button
                        // document.getElementById('btn-play').disabled = true;
                        // document.getElementById('btn-pause').disabled = false;

                        //if the video is not playing with the animation go out without playing the animation
                        // if not we should pass to the next instruction's to play the animations
                        if (!playwith)
                            return;
                    }

                    //play the timeline animation
                    tl.play(p);
                    //enable the pause button & disable the play button
                    // document.getElementById('btn-play').disabled = true;
                    // document.getElementById('btn-pause').disabled = false;

                },
                pause(p = null) {

                    //check if the animation is curently playing a video
                    if (tl.nextLabel()?.indexOf('vid') == 0) {

                        let splitedLabel = tl.nextLabel().split('@');

                        if (splitedLabel.length < 2)
                            return;

                        let playwith = false;

                        if (splitedLabel.length > 2)
                            if (splitedLabel[2] == 'playwith')
                                playwith = true;

                        var vidid = splitedLabel[1];

                        var currVid = document.getElementById(vidid);
                        //if the video is played then pause it
                        currVid.pause();
                        // document.getElementById('btn-play').disabled = false;
                        // document.getElementById('btn-pause').disabled = true;
                        // return;
                    }

                    //if 'p' is not null then pause the animation on a specific progress
                    if (p)
                        tl.progress(p);
                    // tl.pause();

                    // document.getElementById('btn-play').disabled = false;
                    // document.getElementById('btn-pause').disabled = true;
                },
                //it will do the same functionality of play but it will resume the animation from both derictions (reverse or simple)
                resume() {

                    // if (!tl.isActive() && (tl.progress() == 0 || tl.progress() == 1)) {
                    //     this.play(0);
                    //     return;
                    // }

                    if (tl.nextLabel()?.indexOf('vid') == 0) {

                        let splitedLabel = tl.nextLabel().split('@');

                        if (splitedLabel.length < 2)
                            return;

                        let playwith = false;

                        if (splitedLabel.length > 2)
                            if (splitedLabel[2] == 'playwith')
                                playwith = true;

                        var vidid = splitedLabel[1];

                        var currVid = document.getElementById(vidid);
                        currVid.play();
                        // document.getElementById('btn-play').disabled = true;
                        // document.getElementById('btn-pause').disabled = false;

                        if (!playwith)
                            return;
                    }

                    tl.resume();
                    // document.getElementById('btn-play').disabled = true;
                    // document.getElementById('btn-pause').disabled = false;
                },
                selectPart(part) {
                    console.log(part);
                    if (this.selected_part == part || !part) {
                        this.selected_part = {};
                        this.css = '';
                        this.html = '';
                        this.script = '';
                        this.admin_script = '';
                        this.gsap = [];
                        this.id = null;
                        return;
                    }
                    this.selected_part = part;

                    this.css = this.selected_part.css;
                    this.html = this.selected_part.html;
                    this.script = this.selected_part.script;
                    this.admin_script = this.selected_part.admin_script;
                    this.gsap = JSON.parse(this.selected_part.gsap);
                    this.id = this.selected_part.id;

                    part.endCallback = (obj) => {
                        // this.endTimeline = true;
                        // this.pause();
                        // alert(obj.answers);
                    }


                    // send the selected part to all users
                    socket.emit('selectpart.' + this.room, part);

                },
                deletePart(index) {
                    this.evaluation.parts.splice(index, 1);
                },
                upPart(index) {
                    if (index <= 0)
                        return;

                    let temp = {
                        ...this.evaluation.parts[index]
                    };
                    this.evaluation.parts[index] = this.evaluation.parts[index - 1];
                    this.evaluation.parts[index - 1] = temp;
                },
                downPart(index) {
                    if (index + 1 >= this.evaluation.parts.length)
                        return;

                    let temp = {
                        ...this.evaluation.parts[index]
                    };
                    this.evaluation.parts[index] = this.evaluation.parts[index + 1];
                    this.evaluation.parts[index + 1] = temp;
                },
                refreshParticipant(room) {
                    this.participants = [];
                    room.participants.forEach((participant) => {
                        this.participants.push(participant);
                    })
                },
                startPart() {
                    if (!this.selected_part) return;
                    this.load();
                    socket.emit('startpart.' + this.room);
                },
                receiveMessage(msg) {

                },
                getVideoElement(vidid, parentElement) {

                    //check if the video is already exist
                    var vid = document.getElementById(vidid);
                    if (vid) {
                        return vid;

                        //if the video is not exist create new one
                    } else {
                        var vid = document.createElement('video');
                        vid.id = vidid;
                        // add class d-note
                        vid.classList.add('d-note');

                        // add the video element to the parent element
                        parentElement.appendChild(vid);
                        return vid;
                    }
                },
                connectToRoom(room) {
                    //get all participants in room
                    socket.emit('join.' + room);

                    //somone has joined the room
                    socket.on('join.' + room, ({
                        message,
                        room
                    }) => {
                        this.refreshParticipant(room);
                    });

                    //somone has leaved the room
                    socket.on('leave.' + room, ({
                        message,
                        room
                    }) => {
                        this.refreshParticipant(room);
                    });

                    //receive messages from room
                    socket.on('chat.' + room, (msg) => {
                        this.receiveMessage(msg);
                    });

                    // get users progress 
                    socket.on('progresspart.' + room, (progressObj) => {

                        let indexOfParticipant = this.participants.findIndex(participant => participant.username == progressObj.username);

                        if (indexOfParticipant == -1)
                            return;

                        this.participants[indexOfParticipant].progress = progressObj.progress;

                    });

                    // completepart
                    socket.on('completepart.' + room, ({ obj, username }) => {

                        console.log(obj, username);

                        let indexOfParticipant = this.participants.findIndex(participant => participant.username == username);

                        if (indexOfParticipant == -1)
                            return;

                        this.participants[indexOfParticipant].answers = obj.answers;

                    });

                },
                restartParticipantPart(participant) {
                    socket.emit('participant.restartpart.' + this.room, { participant, part: this.selected_part });
                },
                stopParticipantPart(participant) {
                    socket.emit('participant.stoppart.' + this.room, participant);
                },
                showParticipantsAnswersModal() {
                    $('#participantsAnswersModal').modal('show');
                }
            },
        }).mount('#app');
    </script>

</body>

</html>